\documentclass[]{ltjsarticle}
\usepackage{luatexja}


\usepackage{amsmath, amssymb, latexsym, mathrsfs, bm}
\usepackage[qm]{qcircuit}
\usepackage{braket}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage[svgnames]{xcolor}
\usepackage[
     colorlinks        = true,
     unicode           = true,
     pdfstartview      = FitV,
     linktocpage       = true,
     linkcolor         = OrangeRed,
     citecolor         = MediumSeaGreen,
     urlcolor          = RoyalBlue,
     bookmarks         = true,
     bookmarksnumbered = true,
     pdftitle={},
     pdfauthor={筒井翔一朗}
]{hyperref}


%% Numerical constats
\newcommand{\e}{\mathrm{e}}
\newcommand{\im}{\mathrm{i}\mkern1mu}


%% Derivative
\newcommand{\del}{\partial}


%% Mathcal
\newcommand{\calD}{\mathcal{D}}


%% Hat (used for operator on Hilbert space)
\newcommand{\hH}{\hat{H}}


%% Mathematical symbols
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\Tprod}{\mathrm{T}}
\renewcommand{\Re}{\mathrm{Re}}
\renewcommand{\Im}{\mathrm{Im}}

\newcommand{\complex}{\mathbb{C}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


\title{量子計算ミニマム}


\author{筒井翔一朗}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
\begin{abstract}
    これは、ものすごい勢いで量子計算について学ぶためのノートです。
\end{abstract}
\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notation}
Qubit
\begin{align}
    \ket{0} 
    = 
    \begin{pmatrix}
    1 \\ 0    
    \end{pmatrix}, \quad 
    %
    \ket{1} 
    = 
    \begin{pmatrix}
    0 \\ 1    
    \end{pmatrix}, \quad 
\end{align}

Kronecker積
\begin{align}
    A \otimes B 
    \equiv
    \begin{pmatrix}
        a_{11}B & \dots & a_{1N}B \\
        \vdots & \ddots & \vdots \\
        a_{N1}B & \dots & a_{NN}B
    \end{pmatrix}
\end{align}

Pauliゲート
\begin{align}
    X = 
    \begin{pmatrix}
    0 & 1 \\ 1 & 0     
    \end{pmatrix},\quad 
    %
    Y = 
    \begin{pmatrix}
    0 & -i \\ i & 0     
    \end{pmatrix},\quad 
    %
    Z = 
    \begin{pmatrix}
    1 & 0 \\ 0 & -1     
    \end{pmatrix} 
\end{align}

Hadamardゲート
\begin{align}
    H 
    = 
    \frac{1}{\sqrt{2}}
    \begin{pmatrix}
        1 & 1 \\
        1 & -1
    \end{pmatrix}
\end{align}

一般位相ゲート
\begin{align}
    R_l
    =
    \begin{pmatrix}
        1 & 0 \\
        0 & e^{i\frac{2\pi}{2^l}}
    \end{pmatrix}
\end{align}

整数$k$の2進数表記
\begin{align}
    (k)_2 = i_1 i_2 \cdots, \quad i_n = 0, 1
\end{align}

例
\begin{align}
    (0)_2 &= 0 \\
    (1)_2 &= 1 \\
    (2)_2 &= 10 \\
    (3)_2 &= 11 \\
    (4)_2 &= 100 \\
    (5)_2 &= 101 \\
    (6)_2 &= 110 \\
    (7)_2 &= 111 \\
    (8)_2 &= 1000 \\
    (9)_2 &= 1001 \\
    (10)_2 &= 1010 \\
    (11)_2 &= 1011 \\
    (12)_2 &= 1100 \\
    (13)_2 &= 1101
\end{align}

小数を含む2進数表記
\begin{align}
    (k)_2 
    =
    k_1 \cdots k_{l-1}. k_l \cdots k_n
    =
    \cdots + k_{l-1} 2^{0}
    +
    \frac{k_l}{2^1}
    +
    \frac{k_{l+1}}{2^2}
    +
    \cdots
    +
    \frac{k_n}{2^{n-l+1}}
\end{align}
$(k)_2 = k_1 k_2 \cdots k_n$のとき
\begin{align}
    k 
    = 
    k_1 2^{n-1}
    +
    k_2 2^{n-2}
    +
    \cdots
    +
    k_n 2^0
\end{align}
例えば、
\begin{align}
    9 
    = 
    1 \times 2^{3}
    +
    0 \times 2^{2}
    +
    0 \times 2^{1}
    +
    1 \times 2^0
\end{align}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{測定}
\subsection{射影測定}
$A$を物理量、すなわちエルミート演算子とする。
$A$の固有値と固有ベクトルをそれぞれa, $\ket{a}$とする。
$a$は離散的な値を取るものとする。
\begin{align}
    A\ket{a} = a\ket{a}
\end{align}
量子力学における測定とは、$A$の固有値を測る行為のことである。
一般に、測定のたびに得られる固有値は異なり、
状態$\ket{\psi}$に対して$A$を測定して、
固有値$a$が得られる確率は
\begin{align}
    P_a = |\ket{a}\braket{a|\psi}|^2
\end{align}
で与えられる。
測定が行われた後の状態は
\begin{align}
    \frac{1}{|\ket{a}\braket{a|\psi}|}\ket{a}\braket{a|\psi}
\end{align}
となる。

例えば、状態
\begin{align}
    \ket{\psi} 
    =
    \alpha\ket{0}   
    +
    \beta\ket{1}, \quad 
    %
    |\alpha|^2 + |\beta|^2 = 1
\end{align}
に対して、
\begin{align}
    Z =
    \begin{pmatrix}
        1 & 0 \\
        0 & -1
    \end{pmatrix}
\end{align}
の固有値を測定することを考える。
$\ket{0}$, $\ket{1}$は$Z$の固有状態である。
\begin{align}
    Z \ket{0} = \ket{0}, \quad 
    Z \ket{1} = -\ket{1} 
\end{align}
よって、測定値が1である確率は
\begin{align}
    P_01
    = 
    |\ket{0}\braket{0|\psi}|^2
    =
    |\braket{0|\psi}|^2
    =
    |\alpha|^2
\end{align}
であり、測定値が$-1$である確率は
\begin{align}
    P_{-1} = |\beta|^2
\end{align}
である。
この測定は頻繁に登場するが、
$\ket{\psi}$が$\ket{0}$ or $\ket{1}$のどっちになっているかを測定する、
という言い方をする場合がある。

また、状態空間がテンソル積で与えられていて、
部分系のみを測定するということも可能である。
状態$\ket{\psi}\otimes\ket{\psi'}$
に対して、1番目の部分系に作用する演算子$A$を測定して、
固有値$a$が得られる確率は
\begin{align}
    P_a 
    = |(\ket{a}\bra{a} \otimes I) \ket{\psi}\otimes\ket{\psi'}|^2
    = |\ket{a}\braket{a|\psi}\otimes\ket{\psi'}|^2
\end{align}
で与えられる。



\subsection{POVM}
ここでは有限次元のHilbert空間のみ考える。
半正定値行列のセット$\{F_i\}$で
\begin{align}
    \sum_i F_i = I
\end{align}
を満たすようなものを
positive operator-valued measure (POVM)
と呼ぶ。
量子状態$\rho$を測定して、出力$i$が得られる確率は
\begin{align}
    \tr(\rho F_i)    
\end{align}
で与えられる。

例として、純粋状態
\begin{align}
    \rho = \ket{\psi}\bra{\psi}, \quad 
    \ket{\psi} 
    =
    \frac{\alpha}{|\alpha|^2+|\alpha|^2} 
    \ket{0}   
    +
    \frac{\beta}{|\alpha|^2+|\alpha|^2}
    \ket{1}   
\end{align}
と、POVM
\begin{align}
    F_0 = \frac{1 + Z}{2}
    = \begin{pmatrix}
        1 & 0 \\ 0 & 0
    \end{pmatrix}, \quad 
    F_1 = \frac{1 - Z}{2} 
    = \begin{pmatrix}
        0 & 0 \\ 0 & 1
    \end{pmatrix}, \quad 
\end{align}
を考える。
測定によって出力0が得られる確率は
\begin{align}
    \tr(\rho F_0)
    =
    \tr(\ket{\psi}\bra{\psi} F_0)
    =
    \bra{\psi}F_0\ket{\psi}
    =
    \frac{\alpha^2}{|\alpha|^2+|\alpha|^2}
\end{align}
出力1が得られる確率は
\begin{align}
    \tr(\rho F_1)
    =
    \tr(\ket{\psi}\bra{\psi} F_1)
    =
    \bra{\psi}F_1\ket{\psi}
    =
    \frac{\beta^2}{|\alpha|^2+|\alpha|^2}
\end{align}
である。
これはいわゆるBornの規則である。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{量子ビットと演算}
古典計算機では、$0,1$の2値を取りうるbitたちと、
NOT, AND, ORなどの論理演算を電子回路を用いて実装でき、
これらを駆使して様々なアルゴリズムを構成している。
一方量子計算機では、
bitの役割を果たすのは内部自由度が2の量子論的な粒子である。
これをqubitと呼ぶ。
qubitの振る舞いは量子力学によって記述される。
\begin{enumerate}
    \item ひとつのqubitの状態は、$\complex$上の2次元Hilbert空間の元で表すことができる。
    \item 複数のqubitがある場合はそれらのテンソル積で表現される。(例えば、$N$個のqubit系は$2^N$次元のHilbert空間の元である。)
    \item qubit系が孤立しているとき、qubit系の時間変化はユニタリー変換を用いて記述される。
\end{enumerate}
量子計算機では、qubit系にユニタリー変換を繰り返し作用させることで、
所望のアルゴリズムを構成する。
ユニタリー変換しか許さないというのは強力な縛りで、
古典計算機とはずいぶん様子が異なる。
（例えばANDを考えてみよ。）

古典的な計算においては、
任意の論理関数がNOTとANDの組み合わせで表現できることが証明でき、
このとき組\{NOT, AND\}は万能であるというのだった。
このような性質のために、どんなに複雑な操作も、
単純な論理演算の組み合わせで表現することができる。
これは実機を作る上で重要である。
量子計算にも同様の性質がある。


\subsection{1 bitユニタリー変換}
ここでは1 qubit系とそれに作用するユニタリー変換を考える。
1 qubitの状態は一般に、
\begin{align}
    \ket{\psi} 
    =
    \alpha \ket{0} + \beta\ket{1}
\end{align}
と表すことができる。
ここで、
\begin{align}
    \ket{0} 
    = 
    \begin{pmatrix}
    1 \\ 0    
    \end{pmatrix}, \quad 
    %
    \ket{1} 
    = 
    \begin{pmatrix}
    0 \\ 1    
    \end{pmatrix},
\end{align}
である。これらを計算機基底と呼ぶ。
また、$\alpha, \beta$は$|\alpha|^2 + |\beta|^2 = 1$を満たす複素数で、
しばしば
\begin{align}
    \alpha = \cos\frac{\theta}{2}, \quad 
    \beta = e^{i\phi}\sin\frac{\theta}{2}
\end{align}
とパラメトライズする。
$\theta, \phi$は実数である。
これらを指定すると、半径1の球面上の一点が指定される。
この球面のことをBloch球と呼ぶ。
1 qubit状態に作用するユニタリー変換は、サイズ2の行列で表現することができる。
\begin{align}
    U = 
    \begin{pmatrix}
        u_{11} & u_{12} \\
        u_{21} & u_{22}
    \end{pmatrix}, \quad u_{ij} \in \complex
\end{align}
（この独立なパラメータの数は4）
ユニタリー変換は、Bloch球の点を移す変換になっているはずである。
$x,y,z$軸周りの$\theta$回転は
\begin{align}
    e^{-i(\theta/2)A} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}A,
    \quad 
    A = X, Y, Z
\end{align}
で表される。
ここで、
\begin{align}
    X = 
    \begin{pmatrix}
    0 & 1 \\ 1 & 0     
    \end{pmatrix},\quad 
    %
    Y = 
    \begin{pmatrix}
    0 & -i \\ i & 0     
    \end{pmatrix},\quad 
    %
    Z = 
    \begin{pmatrix}
    1 & 0 \\ 0 & -1     
    \end{pmatrix} 
\end{align}
である。
これらをPauli行列（ゲート）と呼び、以下の性質がある。
\begin{align}
    X^2 &= Y^2 = Z^2 = I \\
    XY - YX &= iZ, \quad 
    YZ - ZX = iX, \quad 
    ZX - XZ = iy, \quad \\
    XY + YX &= YZ + ZY = ZX + XZ = 0
\end{align}
実際例えば、
\begin{align}
    e^{-i(\theta'/2)Z}\ket{\psi} 
    &=
    \left(
        \cos\frac{\theta'}{2}I - i\sin\frac{\theta'}{2}Z
    \right)
    \left(
        \cos\frac{\theta}{2} \ket{0} + e^{i\phi}\sin\frac{\theta}{2}\ket{1}
    \right) \\
    &=
    \cos\frac{\theta'}{2} \cos\frac{\theta}{2} \ket{0} 
    + 
    \cos\frac{\theta'}{2} e^{i\phi}\sin\frac{\theta}{2}\ket{1}
    -
    i\sin\frac{\theta'}{2} \cos\frac{\theta}{2}\ket{0} 
    + 
    i\sin\frac{\theta'}{2} e^{i\phi}\sin\frac{\theta}{2} \ket{1} \\
    &=
    e^{-i\theta'/2}\cos\frac{\theta}{2}\ket{0}
    +
    e^{i\theta'/2}e^{i\phi}\sin\frac{\theta}{2}\ket{1} \\
    &=
    e^{-i\theta'/2}
    \left(
        \cos\frac{\theta}{2}\ket{0}
        +
        e^{i\phi+\theta'}\sin\frac{\theta}{2}\ket{1}
    \right)
\end{align}
などにより、全体の位相を除いて確かに回転になっていることが確認できる。
よって一般に、
\begin{align}
    U = e^{i\alpha} e^{-i(\beta/2)Z} e^{-i(\gamma/2)Y} e^{-i(\delta/2)Z}
\end{align}
のように表すことができる。$\beta, \gamma, \delta$はEuler角である。
（パラメターが4つ）

このような$U$を少数のユニタリー変換の積で表すことができるのだろうか？
実は次が示せる。
\begin{itemize}
    \item $H,T$の積によって、任意の$U$をいくらでも精度良く近似できる。
\end{itemize}
ここで、
\begin{align}
    H 
    = 
    \frac{1}{\sqrt{2}}
    \begin{pmatrix}
        1 & 1 \\
        1 & -1
    \end{pmatrix}, \quad 
    %
    T
    = 
    e^{-i(\pi/8)Z}
\end{align}
である。$H$をHadamardゲートと呼ぶ。
これを示そう。
まずHadamardゲートについて
\begin{align}
    H^{-1} = H, \quad 
    X = HZH
\end{align}
が成り立つことに注意すれば、
\begin{align}
    HTH 
    = 
    He^{-i(\pi/8)Z}H 
    =
    H\left( 
        \cos\frac{\pi}{8}I - i\sin\frac{\pi}{8}Z
    \right)H
    =
    \cos\frac{\pi}{8}I - i\sin\frac{\pi}{8}X
    =
    e^{-i(\pi/8)X}
\end{align}
である。
ここで、$V = THTH$を考え、これがある軸回りの回転を引き起こすことを見る。
一般に、$\vec{n} = (n_x. n_y, n_z)$軸回りの$\theta$回転は
\begin{align}
    e^{-i\theta \vec{n}\cdot\vec{\sigma}/2}
    &=
    1 
    + \left( -i\frac{\theta}{2}\vec{n}\cdot\vec{\sigma} \right)
    + \frac{1}{2}\left( -i\frac{\theta}{2} \vec{n}\cdot\vec{\sigma} \right)^2
    + \frac{1}{3!}\left( -i\frac{\theta}{2} \vec{n}\cdot\vec{\sigma} \right)^3 
    + \cdots \\
    &=
    1 
    - i \left( \frac{\theta}{2} \right) \vec{n}\cdot\vec{\sigma}
    - \frac{1}{2}\left( \frac{\theta}{2} \right)^2
    + i \frac{1}{3!}\left( \frac{\theta}{2} \right)^3 \vec{n}\cdot\vec{\sigma} 
    + \cdots \\
    &=
    \cos\frac{\theta}{2}I 
    -
    i\sin\frac{\theta}{2}
    (n_xX + n_yY + n_zZ)
\end{align}
と表されることに注意する。
ただしここで、
\begin{align}
    (\vec{n}\cdot\vec{\sigma})^2
    &=
    (n_x X + n_y Y + n_z Z)^2 \\
    &=
    n_x^2 X^2 + n_y^2 Y^2 + n_z^2 Z^2
    + n_xn_y (XY + YX)
    + n_yn_z (YZ + ZY)
    + n_zn_x (ZX + XZ) \\
    &=
    I
\end{align}
を用いた。
\begin{align}
    V 
    &= 
    e^{-i(\pi/8)Z}e^{-i(\pi/8)X} \\
    &= 
    \left( 
        \cos\frac{\pi}{8}I - i\sin\frac{\pi}{8}Z
    \right)
    \left( 
        \cos\frac{\pi}{8}I - i\sin\frac{\pi}{8}X
    \right) \\
    &=
    \cos^2\frac{\pi}{8}I
    -
    \sin^2\frac{\pi}{8}ZX
    -
    i\cos\frac{\pi}{8}\sin\frac{\pi}{8}Z
    -
    i\cos\frac{\pi}{8}\sin\frac{\pi}{8}X \\
    &=
    \cos^2\frac{\pi}{8}I
    -
    \sin^2\frac{\pi}{8}(iY)
    -
    i\cos\frac{\pi}{8}\sin\frac{\pi}{8}Z
    -
    i\cos\frac{\pi}{8}\sin\frac{\pi}{8}X \\
    &=
    \cos^2\frac{\pi}{8}I
    -
    i\sin\frac{\pi}{8}
    \left(
        \cos\frac{\pi}{8} X
        +
        \sin\frac{\pi}{8} Y
        +
        \cos\frac{\pi}{8} Z
    \right)
\end{align}
である。
よって、$V$はある軸回りの回転で、その角度は
\begin{align}
    \theta 
    = 2\arccos\frac{2 + \sqrt{2}}{4}
    = \arccos \frac{2\sqrt{2}-1}{4}
\end{align}
である。
これは$\pi$の無理数倍だから、$V$を何度もかけると、
この軸周りの任意の回転を任意の精度で近似できる。
次に$V'=HVH$を考えると、また別の軸の周りの回転について同様のことが言える。
以上を組み合わせることで証明終了。

ちなみに、$\theta$が$\pi$の無理数倍であることは、
$e^{2\pi i \theta}$が$x^4 + x^3 + \frac{1}{4}x^2 + x + 1$
という円分多項式でない多項式のの根であることから従う。
\href{https://arxiv.org/abs/quant-ph/9906054}{
    P. O. Boykin, T. Mor, M. Pulver, V. Roychowdhury, and F. Vatan: 
    arXiv:quant-ph/9906054}
また、Solovay-Kitaevにより、近似に必要なゲートの数は
高々多項式オーダーであることが示されている。



\subsection{2 level ユニタリー変換}
1 bitに作用するユニタリー変換はサイズ2の行列であった。
実は、どんなユニタリー変換も、実質サイズ2の行列の積で表すことができる。
例として、
\begin{align}
    U = 
    \begin{pmatrix}
        a & * & * \\
        b & * & * \\
        * & * & * 
    \end{pmatrix}
\end{align}
を考える。
ここで、2-levelのユニタリー行列として
\begin{align}
    U_1 
    =
    \frac{1}{\sqrt{|a|^2 + |b|^2}}
    \begin{pmatrix}
        a^* & b^* & 0 \\
        b & -a & 0 \\
        0 & 0 & 1 
    \end{pmatrix}
\end{align}
というものを考える。これがユニタリーであることは
\begin{align}
    U_1^{-1}
    =
    \frac{1}{\sqrt{|a|^2 + |b|^2}}
    \begin{pmatrix}
        a & b & 0 \\
        b^* & -a^* & 0 \\
        0 & 0 & 1 
    \end{pmatrix}
\end{align}
から分かる。$U_1$を$U$にかけると
\begin{align}
    U_1U =
    \begin{pmatrix}
        * & * & * \\
        0 & * & * \\
        * & * & * 
    \end{pmatrix}
\end{align}
のようにある成分が0になる。
同じようなことをもう一度やると、
\begin{align}
    U_2U_1U =
    \begin{pmatrix}
        1 & * & * \\
        0 & c & d \\
        0 & e & f 
    \end{pmatrix}
\end{align}
の形にできる。
$U_2U_1U$はユニタリーだからこの段階で自動的に
\begin{align}
    U_2U_1U =
    \begin{pmatrix}
        1 & 0 & 0 \\
        0 & c & d \\
        0 & e & f 
    \end{pmatrix}
\end{align}
となっているはずである。
最後に
\begin{align}
    U_3 =
    \begin{pmatrix}
        1 & 0 & 0 \\
        0 & c & d \\
        0 & e & f 
    \end{pmatrix}^{-1}   
\end{align}
とおけば、$U_3U_2U_1U=I$となる。
よって、$U = U_1^\dagger U_2^\dagger U_3^\dagger$と分解できた。
もっとサイズの大きな$U$についても同様の分解が可能である。



\subsection{2 bitユニタリー変換}
前節の議論から、任意の2つの成分に作用するユニタリー変換が構成できれば十分だということが分かった。
2 bit系の場合についてこれが可能なことを示そう。
2 bit系の基底は$\ket{00}, \ket{01}, \ket{10}, \ket{11}$である。
具体的に計算してみると、
\begin{align}
    \ket{00} 
    =
    \begin{pmatrix}
        1 \\ 0    
    \end{pmatrix}
    \otimes
    \begin{pmatrix}
        1 \\ 0    
    \end{pmatrix}
    =
    \begin{pmatrix}
        1 \\ 0 \\ 0 \\ 0   
    \end{pmatrix} \\
    %
    \ket{01} 
    =
    \begin{pmatrix}
        1 \\ 0    
    \end{pmatrix}
    \otimes
    \begin{pmatrix}
        0 \\ 1    
    \end{pmatrix}
    =
    \begin{pmatrix}
        0 \\ 1 \\ 0 \\ 0   
    \end{pmatrix} \\
    %
    \ket{10} 
    =
    \begin{pmatrix}
        0 \\ 1    
    \end{pmatrix}
    \otimes
    \begin{pmatrix}
        1 \\ 0    
    \end{pmatrix}
    =
    \begin{pmatrix}
        0 \\ 0 \\ 1 \\ 0   
    \end{pmatrix} \\
    %
    \ket{11} 
    =
    \begin{pmatrix}
        0 \\ 1    
    \end{pmatrix}
    \otimes
    \begin{pmatrix}
        0 \\ 1    
    \end{pmatrix}
    =
    \begin{pmatrix}
        0 \\ 0 \\ 0 \\ 1
    \end{pmatrix}
\end{align}
というものである。ここで$\otimes$はKronecker積
\begin{align}
    A \otimes B 
    \equiv
    \begin{pmatrix}
        a_{11}B & \dots & a_{1N}B \\
        \vdots & \ddots & \vdots \\
        a_{N1}B & \dots & a_{NN}B
    \end{pmatrix}
\end{align}
である。
ユニタリー変換として$\ket{10}, \ket{11}$だけに作用する
\begin{align}
    \Lambda(V)
    =
    \begin{pmatrix}
        1 & 0 & 0 & 0 \\ 
        0 & 1 & 0 & 0 \\ 
        0 & 0 & a & b \\ 
        0 & 0 & c & d \\ 
    \end{pmatrix}
\end{align}
を考える。
これは
\begin{align}
    \Lambda(V) = \ket{0}\bra{0} \otimes I + \ket{1}\bra{1} \otimes V, \quad 
    %
    \ket{0}\bra{0}
    =
    \begin{pmatrix}
        1 & 0 \\
        0 & 0  
    \end{pmatrix},\quad
    %
    \ket{1}\bra{1}
    =
    \begin{pmatrix}
        0 & 0 \\
        0 & 1  
    \end{pmatrix},\quad
    V = 
    \begin{pmatrix}
        a & b \\
        c & d  
    \end{pmatrix}
\end{align}
と書くことができる。
このように、$\ket{0}, \ket{1}$への射影演算子を用いて書かれるゲートを
制御$V$ゲートと呼ぶ。
射影演算子が作用するbitを制御bit,
ユニタリー演算子が作用するbitをtarget bitと呼ぶ。

次に、$\ket{00}$と$\ket{11}$だけに作用するもの
\begin{align}
    \begin{pmatrix}
        a & 0 & 0 & b \\ 
        0 & 1 & 0 & 0 \\ 
        0 & 0 & 1 & b \\ 
        c & 0 & 0 & d \\ 
    \end{pmatrix}
\end{align}
を考える。
この場合も
\begin{enumerate}
    \item $\ket{00}$と$\ket{10}$をswapする。
    \item $V$を作用させる。
    \item $\ket{00}$と$\ket{10}$をswapする。
\end{enumerate}
によって、$\Lambda(V)$を作用させる計算に帰着できる。
$\ket{00}$と$\ket{10}$をswapは、「2番目のbitが0ならば1番目のbitを反転させよ」
と読めば、制御演算で表せることが分かる。
具体的には
\begin{align}
    \text{SWAP} = X \otimes \ket{0}\bra{0} + I \otimes \ket{1}\bra{1}
\end{align}
である。この作用を具体的に計算すると、
\begin{align}
    \text{SWAP} \ket{00} &= \ket{10} \\
    \text{SWAP} \ket{01} &= \ket{01} \\
    \text{SWAP} \ket{10} &= \ket{00} \\
    \text{SWAP} \ket{11} &= \ket{11}
\end{align}
となる。
行列表示すると
\begin{align}
    \text{SWAP}
    =
    \begin{pmatrix}
        0 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 \\
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1
    \end{pmatrix}
\end{align}
である。
具体的に計算してみると
\begin{align}
    \text{SWAP}\,\Lambda(V)\,\text{SWAP}
    &=
    \begin{pmatrix}
        0 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 \\
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1
    \end{pmatrix}
    \begin{pmatrix}
        1 & 0 & 0 & 0 \\ 
        0 & 1 & 0 & 0 \\ 
        0 & 0 & a & b \\ 
        0 & 0 & c & d \\ 
    \end{pmatrix}
    \begin{pmatrix}
        0 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 \\
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1
    \end{pmatrix}    \\
    &=
    \begin{pmatrix}
        0 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 \\
        1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1
    \end{pmatrix}    
    \begin{pmatrix}
        0 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 \\
        a & 0 & 0 & b \\
        c & 0 & 0 & d
    \end{pmatrix}    \\
    &=
    \begin{pmatrix}
        a & 0 & 0 & b \\ 
        0 & 1 & 0 & 0 \\ 
        0 & 0 & 1 & b \\ 
        c & 0 & 0 & d \\ 
    \end{pmatrix}
\end{align}
となって確かに所望のユニタリー変換が得られている。

このようにして、bit swapと制御ユニタリー変換をを組み合わせれば、
任意の2 levelユニタリー変換を構成することができる。

制御演算のうち、
\begin{align}
    \Lambda(X) = \ket{0}\bra{0} \otimes I + \ket{1}\bra{1} \otimes X, \quad 
\end{align}
を制御NOTゲート、あるいはCNOTゲートと呼ぶ。
実は、任意の制御ユニタリーゲートは、CNOT, H, Tを用いて表すことができる。


\subsection{3 bit以上のユニタリー変換}
3 bit系でswapをやろうとすると、制御bitが2つのNOTが必要になる。
これをToffoliゲートと呼ぶ。
ToffoliゲートはCNOTとTゲートに分解できる。
また、Toffoliゲートを組み合わせれば、制御bitが3つ以上のNOTも作れる。
こうして、
CNOT, H, Tの3つのゲートによって任意のユニタリー変換をいくらでも精度良く近似できることが分かった。
この3つのゲートが、量子計算機における万能の組である。




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{基本的な量子アルゴリズム}
\subsection{量子計算機で実行できる操作のまとめ}
量子計算には重要な制約がある。
\begin{enumerate}
    \item アルゴリズムはユニタリー演算として表されなければならない
    \item 出力を得るために測定と呼ばれる操作を行わなければならない
\end{enumerate}


各qubitに対してユニタリー演算子を作用させることができる。
例えば
\begin{align}
    U \ket{\psi} = \ket{\psi'}
\end{align}
といった操作が可能である。
これを、
\[ 
    \Qcircuit 
    @C=1em @R=1em 
    {
        \lstick{\ket{\psi}} & \qw & \gate{U} & \qw & \rstick{\ket{\psi'}}\qw
    }
\]
と表す。
複数のqubitがある場合は、どのqubitに作用するのかを明示するために
\begin{align}
    U_j = I \otimes \cdots \otimes U \otimes \cdots \otimes I
\end{align}
という記法を用いる。例えば、
\begin{align}
    U_0 \ket{\psi_0}\ket{\psi_1} 
    = 
    (U \ket{\psi_0})\ket{\psi_1} 
    = 
    \ket{\psi'_0}\ket{\psi_1}
\end{align}
である。
これは以下のように表す。
\[ 
    \Qcircuit 
    @C=1em @R=1em 
    {
        \lstick{\ket{\psi_0}} & \qw & \gate{U} & \qw & \rstick{\ket{\psi'_0}}\qw \\
        \lstick{\ket{\psi_1}} & \qw & \qw & \qw & \rstick{\ket{\psi_1}}\qw 
    }
\]

上記に加えて、制御ユニタリー演算というものを作用させることができる。
$j$番のqubitを制御系とする$k$番のqubitに対する制御ユニタリー演算とは、
\begin{align}
    \Lambda_{jk}(U)
    =
    \cdots \otimes \underbrace{\ket{0}\bra{0}I}_{j}
    \otimes \cdots \otimes \underbrace{\ket{1}\bra{1}I}_{k} 
    \otimes \cdots
\end{align}
である。$\cdots$で省略したところにはすべて$I$が入る。
特に、$U=X$の場合をCNOTゲートと呼ぶ。




\subsection{アダマールテスト}
$U$をユニタリー演算子とする。
以下のゲート
\[ 
    \Qcircuit 
    @C=1em @R=1em 
    {
        \lstick{\ket{0}}              & \gate{H} & \ctrl{1} & \gate{H} & \meter \\
        \lstick{\ket{\psi_\text{in}}} & \qw      & \gate{U} & \qw      & \rstick{\ket{\psi_\text{out}}}\qw
    }
\]
を考える。
control U gateを式で表すと、
\begin{align}
    \ket{0}\bra{0}\otimes I + \ket{1}\bra{1}\otimes U
\end{align}
であることに注意して、この回路を式で書くと、
測定の直前の状態は
\begin{align}
    &(H\otimes I) 
    (\ket{0}\bra{0}\otimes I + \ket{1}\bra{1}\otimes U)
    (H\otimes I) 
    \ket{0}\ket{\psi_\text{in}} \\
    =
    &(H\otimes I)
    (\ket{0}\bra{0}\otimes I + \ket{1}\bra{1}\otimes U)
    \frac{\ket{0}\ket{\psi_\text{in}} + \ket{1}\ket{\psi_\text{in}}}{\sqrt{2}} \\
    =
    &(H\otimes I)
    \left(
        \frac{\ket{0}\ket{\psi_\text{in}}}{\sqrt{2}}
        +
        \frac{\ket{1}U\ket{\psi_\text{in}}}{\sqrt{2}}
    \right) \\
    =
    &\frac{1}{\sqrt{2}}
    (H\otimes I)
    \left(
        \ket{0}\ket{\psi_\text{in}}
        +
        \ket{1}U\ket{\psi_\text{in}}
    \right) \\
    =
    &\frac{1}{\sqrt{2}}
    \left(
        \frac{\ket{0} + \ket{1}}{\sqrt{2}}\ket{\psi_\text{in}}
        +
        \frac{\ket{0} - \ket{1}}{\sqrt{2}}U\ket{\psi_\text{in}}
    \right) \\
    =
    &
    \frac{\ket{0} + \ket{1}}{2}\ket{\psi_\text{in}}
    +
    \frac{\ket{0} - \ket{1}}{2}U\ket{\psi_\text{in}} \\
    =
    &
    \ket{0}\frac{I + U}{2}\ket{\psi_\text{in}}
    +
    \ket{1}\frac{I - U}{2}\ket{\psi_\text{in}}
\end{align}
となる。
第一のqubitが$\ket{0}$である確率は
\begin{align}
    p_0
    &=
    \left|
        (\ket{0}\bra{0} \otimes I)
        \left(
            \ket{0}\frac{I + U}{2}\ket{\psi_\text{in}}
            +
            \ket{1}\frac{I - U}{2}\ket{\psi_\text{in}}
        \right)
    \right|^2 \\
    &=
    \left|
        \ket{0}\frac{I + U}{2}\ket{\psi_\text{in}}
    \right|^2 \\
    &=
    \left(
        \bra{\psi_\text{in}}\frac{I + U^\dagger}{2}\bra{0}
    \right)
    \left(
        \ket{0}\frac{I + U}{2}\ket{\psi_\text{in}}
    \right) \\
    &=
    \bra{\psi_\text{in}}
    \frac{I + U + U^\dagger + U^\dagger U}{4}
    \ket{\psi_\text{in}} \\
    &=
    \bra{\psi_\text{in}}
    \frac{2I + U + U^\dagger}{4}
    \ket{\psi_\text{in}} \\
    &=
    \frac{1 + \Re\bra{\psi_\text{in}}U\ket{\psi_\text{in}}}{2}
\end{align}
となり、
第一のqubitが$\ket{1}$である確率は
\begin{align}
    p_1
    &=
    \left|
        (\ket{1}\bra{1} \otimes I)
        \left(
            \ket{0}\frac{I + U}{2}\ket{\psi_\text{in}}
            +
            \ket{1}\frac{I - U}{2}\ket{\psi_\text{in}}
        \right)
    \right|^2 \\
    &=
    \left|
        \ket{1}\frac{I - U}{2}\ket{\psi_\text{in}}
    \right|^2 \\
    &=
    \left(
        \bra{\psi_\text{in}}\frac{I - U^\dagger}{2}\bra{1}
    \right)
    \left(
        \ket{1}\frac{I - U}{2}\ket{\psi_\text{in}}
    \right) \\
    &=
    \bra{\psi_\text{in}}
    \frac{I - U - U^\dagger + U^\dagger U}{4}
    \ket{\psi_\text{in}} \\
    &=
    \bra{\psi_\text{in}}
    \frac{2I - U - U^\dagger}{4}
    \ket{\psi_\text{in}} \\
    &=
    \frac{1 - \Re\bra{\psi_\text{in}}U\ket{\psi_\text{in}}}{2}
\end{align}
となる。
従って、この回路では演算子$U$の$\bra{\psi_\text{in}}$における期待値を推定することができる。

測定の結果、第一番目のqubitが$\ket{0}, \ket{1}$だった場合、
残りの状態はそれぞれ、
\begin{align}
    \ket{\psi_\text{out}}
    =
    \ket{\psi_0}
    =
    \frac{I + U}{2}
    \ket{\psi_\text{in}}, \quad
    %
    \ket{\psi_\text{out}}
    =
    \ket{\psi_1}
    =
    \frac{I - U}{2}
    \ket{\psi_\text{in}}
\end{align}
となる。



\subsection{量子フーリエ変換}
$x_j$を$2^n$成分ベクトルとする。
これは規格化$\sum_{j=0}^{2^n-1} |x_j|^2 = 1$
されているとする。
この離散フーリエ変換
\begin{align}
    y_k 
    = 
    \frac{1}{\sqrt{2^n}}
    \sum_{j=0}^{2^n-1} x_j e^{i\frac{2\pi jk}{2^n}}
\end{align}
を量子回路を用いて計算する方法について述べる。

整数$j$に対してその2進数表記をラベルに持つような量子状態を考え、
次のように書く。
\begin{align}
    \ket{(j)_2} = \ket{i_1 i_2 \cdots}
\end{align}
例えば
\begin{align}
    \ket{(6)_2} 
    = 
    \ket{110} 
    = 
    \ket{1} \otimes \ket{1} \otimes \ket{0} 
    =
    \begin{pmatrix}
        0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0
    \end{pmatrix}
\end{align}
である。
この約束のもと、次のような状態を考える
\begin{align}
    \ket{x}\rangle 
    \equiv 
    \sum_{j=0}^{2^n-1} x_j \ket{(j)_2}, \quad
    %
    \ket{y}\rangle 
    \equiv 
    \sum_{j=0}^{2^n-1} y_j \ket{(j)_2}
\end{align}
$\ket{y}\rangle$を$x_j$で表すと
\begin{align}
    \ket{y}\rangle 
    &=
    \sum_{k=0}^{2^n-1} y_k \ket{(k)_2} \\
    &=
    \frac{1}{\sqrt{2^n}}
    \sum_{j=0}^{2^n-1}     
    \sum_{k=0}^{2^n-1}
    x_j e^{i\frac{2\pi jk}{2^n}}
    \ket{(k)_2} \\
    &=
    \sum_{j=0}^{2^n-1}     
    x_j
    \left(
        \frac{1}{\sqrt{2^n}}
        \sum_{k=0}^{2^n-1}
        e^{i\frac{2\pi jk}{2^n}}
        \ket{(k)_2}    
    \right)
\end{align}
となる。
もし、あるユニタリー変換で、
\begin{align}
    U \ket{(j)_2}
    =
    \frac{1}{\sqrt{2^n}}
    \sum_{k=0}^{2^n-1}
    e^{i\frac{2\pi jk}{2^n}}
    \ket{(k)_2}    
\end{align}
となるようなものがあったとすると、
\begin{align}
    U \ket{x}\rangle 
    =
    \ket{y}\rangle
\end{align}
となる。
$\ket{y}\rangle$の係数を読み取ることで、
フーリエ変換の結果を知ることができる。

以下で、そのような$U$を具体的に構成する。
ビット数は$n$で固定する。
\begin{align}
    \sum_{k=0}^{2^n-1}
    e^{i\frac{2\pi jk}{2^n}}
    \ket{(k)_2}    
    &=
    \sum_{k_1=0,1}
    \cdots 
    \sum_{k_n=0,1}
    e^{i\frac{2\pi j (k_12^{n-1} + \cdots + k_02^{0})}{2^n}}
    \ket{k_1 \cdots k_n} \\
    &=
    \sum_{k_1=0,1}
    \cdots 
    \sum_{k_n=0,1}
    e^{i 2\pi j (k_12^{-1} + \cdots + k_02^{-n})}
    \ket{k_1 \cdots k_n} \\  
    &=
    \left(
        \sum_{k_1=0,1}
        e^{i2\pi j k_1 2^{-1}}
        \ket{k_1}
    \right)
    \otimes 
    \cdots 
    \otimes 
    \left(
        \sum_{k_n=0,1}
        e^{i2\pi j k_n 2^{-n}}
        \ket{k_n}
    \right) \\
    &=
    \left(
        \ket{0} 
        + 
        e^{i2\pi j 2^{-1}} \ket{1}
    \right)
    \otimes 
    \cdots 
    \otimes 
    \left(
        \ket{0} 
        + 
        e^{i2\pi j 2^{-n}} \ket{1}
    \right)
\end{align}
ここで、$j2^{-l}$という因子の2進数表記について考える。
\begin{align}
    (j)_2 = j_1 j_2 \cdots j_n 
\end{align}
とすると、 
\begin{align}
    j = j_1 2^{n-1} + j_2 2^{n-2} + \cdots + j_n2^0
\end{align}
であるから
\begin{align}
    j2^{-l} = j_1 2^{n-l-1} + j_2 2^{n-l-2} + \cdots + j_n2^{-l}
\end{align}
である。
よって、これを2進数表記すると
\begin{align}
    (j2^{-1})_2 &= (\text{整数部分}).j_n \\
    (j2^{-2})_2 &= (\text{整数部分}).j_{n-1}j_n \\
    \vdots& \\
    (j2^{-l})_2 &= (\text{整数部分}).j_{n-l+1}\cdots j_{n-1}j_n \\
    \vdots& \\
    (j2^{-n})_2 &= (\text{整数部分}).j_{1}\cdots j_{n-1}j_n \\
\end{align}
となる。
また、一般に
\begin{align}
    e^{i 2\pi j_1 \cdots j_{l-1}. j_l \cdots j_n}
    &=
    e^{
        i 2\pi 
        \left(
            \dots
            +
            j_{l-2}2^1
            +
            j_{l-1} 
            +
            \frac{j_l}{2^1}
            \cdots
            +
            \frac{j_n}{2^{n-l+1}}       
        \right)
    } \\
    &=
    \cdots
    e^{i 2\pi j_{l-2}2^1}
    e^{i 2\pi j_{l-1}}
    e^{i 2\pi \frac{j_l}{2^1}}
    \cdots
    e^{i 2\pi \frac{j_n}{2^{n-l+1}}} \\
    &=
    e^{i 2\pi \frac{j_l}{2^1}}
    \cdots
    e^{i 2\pi \frac{j_n}{2^{n-l+1}}} \\
    &=
    e^{
        i 2\pi 
        \left(
            \frac{j_l}{2^1}
            \cdots
            +
            \frac{j_n}{2^{n-l+1}}       
        \right)
    }\\
    &=
    e^{i 2\pi 0. j_l \cdots j_n}
\end{align}
のように整数部分は効いてこないことに注意すると、
\begin{align}
    \sum_{k=0}^{2^n-1}
    e^{i\frac{2\pi jk}{2^n}}
    \ket{(k)_2}    
    &=
    \left(
        \ket{0} 
        + 
        e^{i2\pi j 2^{-1}} \ket{1}
    \right)
    \otimes 
    \cdots 
    \otimes 
    \left(
        \ket{0} 
        + 
        e^{i2\pi j 2^{-n}} \ket{1}
    \right) \\
    &=
    \left(
        \ket{0} 
        + 
        e^{i2\pi 0.j_n} \ket{1}
    \right)
    \otimes 
    \cdots 
    \otimes 
    \left(
        \ket{0} 
        + 
        e^{i2\pi 0.j_1 \cdots j_n} \ket{1}
    \right)
\end{align}
を得る。
よって、求めるべきユニタリー変換$U$とは
\begin{align}
    U \ket{(j)_2}
    =
    \frac{1}{\sqrt{2^n}}
    \left(
        \ket{0} 
        + 
        e^{i2\pi 0.j_n} \ket{1}
    \right)
    \otimes 
    \cdots 
    \otimes 
    \left(
        \ket{0} 
        + 
        e^{i2\pi 0.j_1 \cdots j_n} \ket{1}
    \right)
\end{align}
となるようなものである。

まず、Hadamardゲートが状態に対して
\begin{align}
    H \ket{j} 
    = \frac{\ket{0} + (-1)^{j}\ket{1}}{\sqrt{2}}
\end{align}
と作用することを思い出す。
ここで、2進小数を導入すると
\begin{align}
    e^{i 2\pi 0.0} = 1, \quad 
    e^{i 2\pi 0.1} = e^{\frac{i 2\pi}{2}} = -1
\end{align}
であるから、
\begin{align}
    H \ket{j} 
    = \frac{\ket{0} + e^{i 2\pi 0.j}\ket{1}}{\sqrt{2}}
\end{align}
と表すことができる。
このことを用い、まず第一番目のbitにHadamardゲートを作用させると
\begin{align}
    (H \otimes I \otimes \cdots)\ket{j_1j_2\cdots j_n}
    =
    \left(
        \frac{\ket{0} + e^{i 2\pi 0.j_1}\ket{1}}{\sqrt{2}}
    \right)
    \ket{j_2\cdots j_n}
\end{align}
となる。
次に、2番目のbitを制御ゲートとする位相ゲート$R_2$を一番目のゲートに作用させる。
3番目以降のbitは関与しないから、1,2番目のbitだけに注目して計算してみる。
\begin{align}
    \left(
        I \otimes \ket{0}\bra{0}
        + 
        R_2 \otimes \ket{1}\bra{1}
    \right)
    \left(
        \frac{\ket{0} + e^{i 2\pi 0.j_1}\ket{1}}{\sqrt{2}}
    \right)
    \ket{0}
    &=
    \frac{\ket{00} + e^{i 2\pi 0.j_1}\ket{10}}{\sqrt{2}}
    =
    \frac{\ket{00} + e^{i 2\pi 0.j_10}\ket{10}}{\sqrt{2}} \\
    %
    \left(
        I \otimes \ket{0}\bra{0}
        + 
        R_2 \otimes \ket{1}\bra{1}
    \right)
    \left(
        \frac{\ket{0} + e^{i 2\pi 0.j_1}\ket{1}}{\sqrt{2}}
    \right)
    \ket{1}
    &=
    \left(
        \frac{\ket{0} + e^{i\frac{2\pi}{2^2}}e^{i 2\pi 0.j_1}\ket{1}}{\sqrt{2}}
    \right)
    \ket{1}
    =
    \frac{\ket{01} + e^{i 2\pi 0.j_11}\ket{11}}{\sqrt{2}}
\end{align}
この結果をまとめると、
\begin{align}
    \left(
        I \otimes \ket{0}\bra{0}
        + 
        R_2 \otimes \ket{1}\bra{1}
    \right)
    \left(
        \frac{\ket{0} + e^{i 2\pi 0.j_1}\ket{1}}{\sqrt{2}}
    \right)
    \ket{j_2}
    =
    \frac{\ket{0} + e^{i 2\pi 0.j_1j_2}\ket{1}}{\sqrt{2}}
    \ket{j_2}
\end{align}
となる。
まったく同様の計算により、
\begin{align}
    C_{n,1}(R_n)
    \cdots
    C_{3,1}(R_3)
    C_{2,1}(R_2)
    H_1
    \ket{j_1j_2j_3\cdots j_n}
    =
    \frac{\ket{0} + e^{i 2\pi 0.j_1j_2j_3\cdots j_n}\ket{1}}{\sqrt{2}}
    \ket{j_2j_3\cdots j_n}
\end{align}
となる。
以下、残った$\ket{j_2j_3\cdots j_n}$の部分に同様な操作を施す。
\begin{align}
    C_{n-1,2}(R_n)
    \cdots
    C_{3,2}(R_4)
    C_{2,2}(R_3)
    H_2
    \ket{\bullet j_2j_3\cdots j_n}
    &=
    \frac{\ket{0} + e^{i 2\pi 0.j_2j_3\cdots j_n}\ket{1}}{\sqrt{2}}
    \ket{j_3\cdots j_n} \\
    %
    C_{n-1,3}(R_n)
    \cdots
    C_{3,3}(R_5)
    C_{2,3}(R_4)
    H_3
    \ket{\bullet\bullet j_3\cdots j_n}
    &=
    \frac{\ket{0} + e^{i 2\pi 0.j_3\cdots j_n}\ket{1}}{\sqrt{2}}
    \ket{j_4\cdots j_n} \\
    %
    & \vdots
\end{align}
これらをすべて合わせると、
\begin{align}
    \ket{j_1j_2 \cdots j_n}
    \to
    \frac{1}{\sqrt{2^n}}
    \left(
        \ket{0} 
        + 
        e^{i2\pi 0.j_1 \cdots j_n} \ket{1}
    \right)
    \otimes 
    \cdots 
    \otimes 
    \left(
        \ket{0} 
        + 
        e^{i2\pi 0.j_n} \ket{1}
    \right)
\end{align}
を得る。最後にSWAPゲートで状態の入れ替えを行えば完了である。


\subsection{位相推定アルゴリズム}
ユニタリー演算子$U$が固有値$e^{i\lambda_l}$をもち、
対応する固有状態が$\ket{\psi_l}$であるとする。
固有値の位相は$0 \leq \lambda_l \leq 2\pi$として一般性を失わないから、
$\lambda_l/2\pi$は次のように2進展開できる:
\begin{align}
    \frac{\lambda_l}{2\pi}
    =
    \frac{j_1^{(l)}}{2^1} + \cdots + \frac{j_n^{(l)}}{2^n}
\end{align}
ただし、展開が無限次になる場合は、$n$桁で打ち切って近似しているものと考える。
これを次のように表す。
\begin{align}
    \lambda_l = (2\pi) 0.j_1^{(l)}\cdots j_n^{(l)}
\end{align}
一般の量子状態$\ket{\psi}$を$U$の固有状態で展開したときの係数を$c_l$と表すことができる。
\begin{align}
    \ket{\psi} = \sum_l c_l \ket{\psi_l}
\end{align}
このとき、$\ket{\psi}$と$n$桁の補助量子ビット$\ket{00\dots 0}$を
\begin{align}
    V\ket{00\dots 0}\ket{\psi}
    =
    \sum_l c_l \ket{j_1^{(l)}\cdots j_n^{(l)}} \ket{\psi_l}
\end{align}
のように変換するアルゴリズムを量子位相推定と呼ぶ。
例えば、補助ビットが$\ket{0\cdots 0}$となる確率は
\begin{align}
    &\left|
        \ket{0\cdots 0}\bra{0\cdots 0} \otimes I 
        \sum_l c_l \ket{j_1^{(l)}\cdots j_n^{(l)}} \ket{\psi_l}
    \right|^2 \\
    =
    &\left|
        \sum_l c_l 
        \ket{0\cdots 0}\bra{0\cdots 0}\ket{j_1^{(l)}\cdots j_n^{(l)}} 
        \ket{\psi_l}
    \right|^2 \\
    =
    &\sum_{ll'} c_l c_{l'}^* 
    \bra{\psi_{l'}}
    \bra{j_1^{(l')}\cdots j_n^{(l')}}\ket{0\cdots 0}
    \bra{0\cdots 0}
    \ket{0\cdots 0}
    \bra{0\cdots 0} \ket{j_1^{(l)}\cdots j_n^{(l)}} 
    \ket{\psi_l} \\
    =
    &\sum_{ll'} c_l c_{l'}^* \delta_{ll'}
    \bra{j_1^{(l')}\cdots j_n^{(l')}}\ket{0\cdots 0}
    \bra{0\cdots 0} \ket{j_1^{(l)}\cdots j_n^{(l)}} \\ 
    =
    &\sum_{l} |c_l|^2 
    \bra{j_1^{(l)}\cdots j_n^{(l)}}\ket{0\cdots 0}
    \bra{0\cdots 0} \ket{j_1^{(l)}\cdots j_n^{(l)}} \\
    =
    &\sum_{l} |c_l|^2 
    \left| \bra{0\cdots 0} \ket{j_1^{(l)}\cdots j_n^{(l)}} \right|^2
\end{align}


まず準備として、ひとつの補助ビットと$U$の固有状態のテンソル積状態を考え、
それにHadamardゲートと制御$U^{2^k}$ゲートを作用させる。
\begin{align}
    C_1(U^{2^{k}}_{2}) H_1 \ket{0}\ket{\psi_l}
    &=
    C_1(U^{2^{k}}_{2}) 
    \frac{\ket{0} + \ket{1}}{\sqrt{2}}
    \ket{\psi_l} \\
    &=
    \frac{\ket{0}}{\sqrt{2}}
    \ket{\psi_l}
    +
    \frac{\ket{1}}{\sqrt{2}} 
    U^{2^{k}}\ket{\psi_l} \\
    &=
    \frac{\ket{0} + e^{2^ki\lambda_l} \ket{1}}{\sqrt{2}}
    \ket{\psi_l}
\end{align}
ここで、
\begin{align}
    2^0 \lambda_l 
    &=
    (2\pi) 2^0 0.j_1^{(l)} \cdots j_n^{(l)}
    =
    (2\pi) 0.j_2^{(l)} \cdots j_n^{(l)} \\
    %
    2^1 \lambda_l 
    &=
    (2\pi) 2^1 0.j_1^{(l)} \cdots j_n^{(l)}
    =
    (2\pi) j_1^{(l)}.j_2^{(l)} \cdots j_n^{(l)} \\
    %
    2^2 \lambda_l 
    &=
    (2\pi) 2^2 0.j_1^{(l)} \cdots j_n^{(l)}
    =
    (2\pi) j_1^{(l)}j_2^{(l)}.j_3^{(l)} \cdots j_n^{(l)} \\
    %
    &\vdots \\
    %
    2^k \lambda_l 
    &=
    (2\pi) 2^k 0.j_1^{(l)} \cdots j_n^{(l)}
    =
    (2\pi) j_1^{(l)} \cdots j_k^{(l)}.j_{k+1}^{(l)} \cdots j_n^{(l)}
\end{align}
であるから、
\begin{align}
    C_1(U^{2^{k}}_{2}) H_1 \ket{0}\ket{\psi_l}
    &=
    \frac{\ket{0} + e^{2^ki\lambda_l} \ket{1}}{\sqrt{2}}
    \ket{\psi_l} \\
    &=
    \frac{\ket{0} + e^{(2\pi i) j_1^{(l)} \cdots j_k^{(l)}.j_{k+1}^{(l)} \cdots j_n^{(l)}} \ket{1}}{\sqrt{2}}
    \ket{\psi_l} \\
    &=
    \frac{\ket{0} + e^{(2\pi i) 0.j_{k+1}^{(l)} \cdots j_n^{(l)}} \ket{1}}{\sqrt{2}}
    \ket{\psi_l}
\end{align}
を得る。
この結果を用いると、
\begin{align}
    &\prod_{k=1}^n C_k(U^{2^{k-1}}_{2}) H_k \ket{00\cdots 0}\ket{\psi_l} \\
    =
    &\frac{1}{\sqrt{2^n}}
    \left(
        \ket{0} + e^{(2\pi i) 0.j_{1}^{(l)} \cdots j_n^{(l)}} \ket{1}
    \right)
    \left(
        \ket{0} + e^{(2\pi i) 0.j_{2}^{(l)} \cdots j_n^{(l)}} \ket{1}
    \right)
    \cdots 
    \left(
        \ket{0} + e^{(2\pi i) 0.j_n^{(l)}} \ket{1}
    \right)
    \ket{\psi_l}
\end{align}
となるが、これは$\ket{j_1j_2 \cdots j_n}$に量子フーリエ変換を施してできる状態に他ならない。
従って、
\begin{align}
    \mathrm{QFT}^{\dagger }\prod_{k=1}^n C_k(U^{2^{k-1}}_{2}) H_k \ket{00\cdots 0}\ket{\psi_l} 
    =
    \ket{j_1^{(l)}j_2^{(l)} \cdots j_n^{(l)}}\ket{\psi_l}
\end{align}
である。
よって、$V = \mathrm{QFT}^{\dagger }\prod_{k=1}^n C_k(U^{2^{k-1}}_{2}) H_k$
とすれば良いことが分かった。



\subsection{Shorの素因数分解アルゴリズム}
正の$N$を整数とし、これを素因数分解したいものとする。
$N$と互いに素な数$x$を用意し、
\begin{align}
    x^r = 1 \mod N
\end{align}
とおく。
これを満たす最小の$r$を$x$の位数と呼ぶ。
大概の場合、位数は偶数になることが知られているらしいので、
以下それを仮定する。
このとき、$x^r - 1$を因数分解することができて
\begin{align}
    (x^{r/2}-1)(x^{r/2}+1) = 0 \mod N
\end{align}
である。
これが成り立つのは
\begin{itemize}
    \item $x^{r/2}\pm 1 = 0 \mod N$である。
    \item $(x^{r/2}-1)$, $(x^{r/2}+1)$が$N$と非自明な公約数を持つ。
\end{itemize}
のどちらかの場合であるが、実は後者になる場合が多いらしいので、
以下それを仮定する。
するとユークリッドの互除法により、
$(x^{r/2}-1)$, $(x^{r/2}+1)$が$N$と非自明な公約数を計算することができ、
$N$の因数がひとつ判明する。
これを繰り返すことで素因数分解が完了する。

例)
うまくいく場合。
\begin{enumerate}
    \item $N=57$とする。 
    \item $x = 5$を取る。
    \item \href{https://www.wolframalpha.com/input?i=5%5Er+-+1+%3D+0+mod+57&lang=ja}{$r = 18$となる。}
    \item $x^{r/2}-1 = 5^9-1 = 1953124$, $x^{r/2}+1 = 5^9+1 = 1953126$である。
        これらは$57$では割り切れない。
    \item $\gcd(5^9-1, 57) = 19$, $\gcd(5^9+1, 57) = 3$である。
\end{enumerate}

失敗する場合。
\begin{enumerate}
    \item $N=57$とする。 
    \item $x = 2$を取る。
    \item $r = 18$となる。
    \item $2^9-1 = 511$, $2^9+1 = 513$である。$513/57=9$である。
    \item $\gcd(2^9-1, 57) = 1$, $\gcd(2^9+1, 57) = 57$である。
\end{enumerate}

さて、この計算で最もしんどいのは$r$を求める部分であるが、
これを量子計算機にやらせることができる。
まず、与えられた$N,x$に対して、ユニタリー演算子
\begin{align}
    U_x = \sum_{y=0}^{N-1} \ket{xy \mod N}\bra{y}
\end{align}
を考える。
この固有値と固有ベクトルは
\begin{align}
    U_x \ket{u_s} 
    &= 
    e^{2\pi i (s/r)} \ket{u_s}, \quad 
    s = 0, \cdots, r-1 \\
    %
    \ket{u_s} 
    &=
    \frac{1}{\sqrt{r}}
    \sum_{k=0}^{r-1}
    e^{-2\pi i (s/r) k}
    \ket{x^k \mod N}
\end{align}
である。
実際、
\begin{align}
    U_x \ket{u_s}
    &=
    \frac{1}{\sqrt{r}}
    \sum_{y=0}^{N-1} 
    \sum_{k=0}^{r-1}
    e^{-2\pi i (s/r) k}
    \ket{xy \mod N}\braket{y|x^k \mod N} \\
    &=
    \frac{1}{\sqrt{r}}
    \sum_{k=0}^{r-1}
    e^{-2\pi i (s/r) k}
    \ket{x^{k+1} \mod N} \\
    &=
    \frac{1}{\sqrt{r}}
    \sum_{k=0}^{r-2}
    e^{-2\pi i (s/r) k}
    \ket{x^{k+1} \mod N}
    +
    \frac{1}{\sqrt{r}}
    e^{-2\pi i (s/r) (r-1)}
    \ket{x^{r} \mod N} \\
    &=
    \frac{1}{\sqrt{r}}
    \sum_{k=0}^{r-2}
    e^{-2\pi i (s/r) k}
    \ket{x^{k+1} \mod N}
    +
    \frac{1}{\sqrt{r}}
    e^{-2\pi i (s/r) (r-1)}
    \ket{1 \mod N} \\
    &=
    \frac{1}{\sqrt{r}}
    \sum_{k=1}^{r-1}
    e^{-2\pi i (s/r) (k-1)}
    \ket{x^{k} \mod N}
    +
    \frac{1}{\sqrt{r}}
    e^{-2\pi i (s/r) (r-1)}
    \ket{x^0 \mod N} \\
    &=
    e^{2\pi i (s/r)}
    \frac{1}{\sqrt{r}}
    \left(
        \sum_{k=1}^{r-1}
        e^{-2\pi i (s/r) k}
        \ket{x^{k} \mod N}
        +
        e^{-2\pi i (s/r) r}
        \ket{x^0 \mod N}    
    \right) \\
    &=
    e^{2\pi i (s/r)}
    \frac{1}{\sqrt{r}}
    \left(
        \sum_{k=1}^{r-1}
        e^{-2\pi i (s/r) k}
        \ket{x^{k} \mod N}
        +
        \ket{x^0 \mod N}    
    \right) \\
    &=
    e^{2\pi i (s/r)}
    \frac{1}{\sqrt{r}}
    \sum_{k=0}^{r-1}
    e^{-2\pi i (s/r) k}
    \ket{x^{k} \mod N} \\
    &=
    e^{2\pi i (s/r)}
    \ket{u_s}
\end{align}
となっている。
従って、$U_x$を量子位相推定することにより、$s/r$を得ることができる。


例えば$N=6, x=5$の場合、$r=2$である。
$U$の行列表示は
\begin{align}
    U_5 
    &= 
    \sum_{y=0}^{5} \ket{5y \mod 6}\bra{y} \\
    &=
    \ket{0 \mod 6}\bra{0}
    +
    \ket{5 \mod 6}\bra{1}
    +
    \ket{10 \mod 6}\bra{2}
    +
    \ket{15 \mod 6}\bra{3}
    +
    \ket{20 \mod 6}\bra{4}
    +
    \ket{25 \mod 6}\bra{5} \\
    &=
    \ket{0}\bra{0}
    +
    \ket{5}\bra{1}
    +
    \ket{4}\bra{2}
    +
    \ket{3}\bra{3}
    +
    \ket{2}\bra{4}
    +
    \ket{1}\bra{5} \\ 
    &=
    \begin{pmatrix}
        1 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 1 \\
        0 & 0 & 0 & 0 & 1 & 0 \\
        0 & 0 & 0 & 1 & 0 & 0 \\
        0 & 0 & 1 & 0 & 0 & 0 \\
        0 & 1 & 0 & 0 & 0 & 0
    \end{pmatrix}
\end{align}
である。
\href{https://ja.wolframalpha.com/input?i=%7B%7B1%2C+0%2C+0%2C+0%2C+0%2C+0%7D%2C+%7B0%2C+0%2C+0%2C+0%2C+0%2C+1%7D%2C+%7B0%2C+0%2C+0%2C+0%2C+1%2C+0%7D%2C+%7B0%2C+0%2C+0%2C+1%2C+0%2C+0%7D%2C+%7B0%2C+0%2C+1%2C+0%2C+0%2C+0%7D%2C+%7B0%2C+1%2C+0%2C+0%2C+0%2C+0%7D%7D}{固有値}
は$e^{2\pi i \times 0} =1$, $e^{2\pi i (1/2)} = -1$である。（縮退がある）
状態を測定して後者が得られれば、$r=2$が得られる。




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{誤り訂正}
\subsection{線形符号による古典誤り訂正}
最も素朴な誤り訂正の方法は多数決である。
例えば、$0$というデータがあったとき、
これを$000$という風に冗長化したデータを作っておけば、
何らかの要因によってビットが部分的に反転してしまい
$010$になったとしても、
反転前のデータは$000$であろうと推定できる。

$k$ビットの情報$v$（成分が$0$ or $1$の$k$成分ベクトル）
があったとし、
これを$n = dk$ビットのベクトルに冗長化することを考える。
冗長化後のベクトルを$v'$, $v$から$v'$への変換を$G$とする。 
\begin{align}
    v' = Gv
\end{align}
$G$は$n \times k$行列である。
この操作を符号化、
$G$を生成行列と呼ぶ。
$G$として冒頭の多数決方式を採用したものを
線形符号と呼ぶ。
例えば、
\begin{align}
    v 
    =
    \begin{pmatrix}
        0 \\ 1 \\ 0
    \end{pmatrix},
    \quad 
    G
    =
    \begin{pmatrix}
        1 & 0 & 0 \\
        1 & 0 & 0 \\
        1 & 0 & 0 \\
        0 & 1 & 0 \\
        0 & 1 & 0 \\
        0 & 1 & 0 \\
        0 & 0 & 1 \\
        0 & 0 & 1 \\
        0 & 0 & 1
    \end{pmatrix},
\end{align}
と取れば、
\begin{align}
    v' = 
    \begin{pmatrix}
        0 \\ 0 \\ 0 \\ 
        1 \\ 1 \\ 1 \\ 
        0 \\ 0 \\ 0
    \end{pmatrix}
\end{align}
となる。

次に、エラーが起きたかどうかを判定する方法を考える。
$n$ビットのベクトルのうち、
$Gv$の形に表されるもの全体の集合を$W$とする。
$W$の元を符号語と呼ぶ。
例えば($k=2$, $d=3$)
\begin{align}
    v = 
    \begin{pmatrix}
    1 \\ 1 \\ 1 \\ 0 \\ 0 \\ 0    
    \end{pmatrix}
\end{align}
は符号語だが、
\begin{align}
    v = 
    \begin{pmatrix}
    1 \\ 0 \\ 1 \\ 0 \\ 0 \\ 0
    \end{pmatrix}
\end{align}
ではない。

各列ベクトルが独立で、$H_cG\equiv 0$ (mod 2)を満たすような
$(n-k) \times n$行列$H_c$があったとする。
これを検査行列と呼ぶ。
任意の符号語$w$について
\begin{align}
    H_c w = H_c Gv = 0
\end{align}
が成り立つ。
また逆に、$H_c w = 0$ならば、
$w$は符号語であることも示せるらしい。
このようにして、符号語の2通りの特徴付けを得た。
\begin{itemize}
    \item $G$を用いた見方: ベクトルが適切に水増しされている。
    \item $H_c$を用いた見方: ブロック内の隣接するビットが等しい。
\end{itemize}

$w \in W$のときに限りゼロになるような
ベクトル$s = H_c w$を$w$のシンドローム、
その成分をシンドローム値と呼ぶ。
ひとつでも0でないシンドローム値があれば、
$w$にはエラーが起きていることになる。
シンドローム値がすべて0のときは、
$w$にはエラーがないか、
エラー自身が$H_c e = 0$を満たしているかのどちらかである。



（例 $k=3, n=9$）
線形符号$G$に対する検査行列は以下を取ればよい。
\begin{align}
    H_c
    =
    \begin{pmatrix}
        1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}
\end{align}
実際
\begin{align}
    \begin{pmatrix}
        1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}    
    \begin{pmatrix}
        1 & 0 & 0 \\
        1 & 0 & 0 \\
        1 & 0 & 0 \\
        0 & 1 & 0 \\
        0 & 1 & 0 \\
        0 & 1 & 0 \\
        0 & 0 & 1 \\
        0 & 0 & 1 \\
        0 & 0 & 1
    \end{pmatrix}
    =
    \begin{pmatrix}
        2 & 0 & 0 \\
        2 & 0 & 0 \\
        0 & 2 & 0 \\
        0 & 2 & 0 \\
        0 & 0 & 2 \\
        0 & 0 & 2
    \end{pmatrix}
    \equiv 
    \begin{pmatrix}
        0 & 0 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0 \\
        0 & 0 & 0
    \end{pmatrix}
\end{align}
となりOKである。
符号語$w$に対して$H_c w$を計算すると、
\begin{align}
    H_c w 
    =    
    \begin{pmatrix}
        1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}    
    \begin{pmatrix}
        0 \\ 0 \\ 0 \\ 
        1 \\ 1 \\ 1 \\ 
        0 \\ 0 \\ 0
    \end{pmatrix}
    =
    \begin{pmatrix}
        0 \\ 0 \\
        2 \\ 2 \\
        0 \\ 0 \\
    \end{pmatrix}
    \equiv
    \begin{pmatrix}
        0 \\ 0 \\
        0 \\ 0 \\
        0 \\ 0 \\
    \end{pmatrix}
\end{align}
となる。
もしエラーが混入していると、
\begin{align}
    H_c w 
    =    
    \begin{pmatrix}
        1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}    
    \left(
        \begin{pmatrix}
            0 \\ 0 \\ 0 \\ 
            1 \\ 1 \\ 1 \\ 
            0 \\ 0 \\ 0
        \end{pmatrix}
        +
        \begin{pmatrix}
            0 \\ 0 \\ 0 \\ 
            1 \\ 0 \\ 0 \\ 
            0 \\ 0 \\ 0
        \end{pmatrix}
    \right)
    =
    \left(
        \begin{pmatrix}
            0 \\ 0 \\
            2 \\ 2 \\
            0 \\ 0 \\
        \end{pmatrix}
        +
        \begin{pmatrix}
            0 \\ 0 \\
            1 \\ 0 \\
            0 \\ 0 \\
        \end{pmatrix}
    \right)
    \equiv
    \begin{pmatrix}
        0 \\ 0 \\
        1 \\ 0 \\
        0 \\ 0 \\
    \end{pmatrix}
\end{align}
となる。


\subsection{量子誤り訂正}
現在知られている量子誤り訂正は、
線形符号を量子計算版とでもいうべきものである。
具体例から考える。
1ビットの情報を3ビットに冗長化することを考える。
ここでは、符号化前の量子状態もあらかじめ3bitで用意しておき、
情報は1bit目に格納しておくことにする。
よって符号化$G$として
\begin{align}
    \ket{000} &\to \ket{000} \\
    \ket{100} &\to \ket{111}
\end{align}
となるようなものを用意できれば良い。
これはCNOTゲート
\begin{align}
    \Lambda_{1,2}(X) 
    &=
    P_0 \otimes I \otimes I
    +
    P_1 \otimes X \otimes I \\
    %
    \Lambda_{1,3}(X) 
    &=
    P_0 \otimes I \otimes I
    +
    P_1 \otimes I \otimes X
\end{align}
で実現できる。
実際、
\begin{align}
    \Lambda_{1,2}(X)\Lambda_{1,3}(X)\ket{000}
    &=
    \ket{000} \\
    %
    \Lambda_{1,2}(X)\Lambda_{1,3}(X)\ket{100}
    &=
    \ket{111}
\end{align}
となる。

次にシンドロームを調べる方法を考える。
\begin{align}
    M_0^{(1)} = \frac{I + Z_1Z_2}{2}, \quad
    M_1^{(1)} = \frac{I - Z_1Z_2}{2}
\end{align}
という2つの演算子を考えると、これらはPOVMをなし、
\begin{align}
    M_0^{(1)} \ket{000} 
    &=
    \frac{1 + 1}{2} \ket{000}
    =
    \ket{000} \\
    %
    M_0^{(1)} \ket{100} 
    &=
    \frac{1 - 1}{2} \ket{100}
    =
    0 \\
    %
    M_0^{(1)} \ket{010} 
    &=
    \frac{1 - 1}{2} \ket{010}
    =
    0 \\
    %
    M_0^{(1)} \ket{110} 
    &=
    \frac{1 + 1}{2} \ket{110}
    =
    \ket{110}
\end{align}
\begin{align}
    M_1^{(1)} \ket{000} 
    &=
    \frac{1 - 1}{2} \ket{000}
    =
    0 \\
    %
    M_1^{(1)} \ket{100} 
    &=
    \frac{1 + 1}{2} \ket{100}
    =
    \ket{100} \\
    %
    M_1^{(1)} \ket{010} 
    &=
    \frac{1 + 1}{2} \ket{010}
    =
    \ket{010} \\
    %
    M_1^{(1)} \ket{110} 
    &=
    \frac{1 - 1}{2} \ket{110}
    =
    0
\end{align}
より、
\begin{align}
    \tr(\ket{ij0}\bra{ij0} M_0^{1})
    =
    \delta_{ij}, \\
    %
    \tr(\ket{ij0}\bra{ij0} M_1^{1})
    =
    1 - \delta_{ij}
\end{align}
となるから、
$M_1^{1}$の期待値が、1,2番のビットに関する
シンドローム値を与えることが分かる。
全く同様にして、
\begin{align}
    M_0^{(2)} = \frac{I + Z_2Z_3}{2}, \quad
    M_1^{(2)} = \frac{I - Z_2Z_3}{2}
\end{align}
も測定すれば、すべてのシンドローム値が得られる。
古典的な誤り訂正の場合、シンドローム値は0か1
であったが、
量子計算の場合はそれ以外の中途半端な値を取りうる。
例えば、$\ket{\psi} = (\ket{000} + \ket{010})/\sqrt{2}$
のとき、
\begin{align}
    M_0^{(1)}\ket{\psi}
    \frac{1}{\sqrt{2}}(\ket{000} + \ket{010})
    =
    \frac{\ket{000}}{\sqrt{2}}
\end{align}
より、
\begin{align}
    \tr(\ket{\psi}\bra{\psi}M_0^{(1)})
    =
    \frac{1}{2}
\end{align}
となる。

以下では簡単のため、
このような位相を変化させるエラーはなく、
ビット反転を引き起こすエラーのみを考える。
そのようなエラーを引き起こす操作は
\begin{align}
    E = X_1^{e_1} X_2^{e_1} X_3^{e_1}
\end{align}
と書ける。ただし、$e_1,e_2,e_3 = 0,1$である。
仮に、$\ket{000}$がオリジナルのデータで、
これに、$e_1 = 1, e_2 = e_3 = 0$のエラーが乗ったとすると、
\begin{align}
    E\ket{000}
    =
    X_1\ket{000}
    =
    \ket{100}
\end{align}
となる。
この状態のシンドローム値を完全に調べると、
1番目のビットに反転があることが分かるから、
状態に再度$X_1$を作用させれば
もとの状態を復元することができる。
\begin{align}
    R\ket{100} = X_1\ket{100} = \ket{000}
\end{align}
これでエラー訂正が完了した。



\subsection{スタビライザー符号}


\subsection{surface code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{参考文献}
\begin{itemize}
    \item \href{http://mercury.yukawa.kyoto-u.ac.jp/~bussei.kenkyu/wp/wp-content/uploads/6200-064217.pdf}{量子コンピュータの基礎と物理の接点}
        は藤井さんによる講義ノート。
    \item \href{http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf}{Quantum Computation and Quantum Information}
        はNielsen, Chuangによる古典的な教科書。10版が無料公開されている。
    \item \href{https://dojo.qulacs.org/ja/latest/}{Quantum Native Dojo}
        は株式会社QunaSysが運営しているサイト。
    \item 古典論理回路については、例えば、「論理回路　高木直史　昭晃堂」
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\bibliography{sample.bib}
%\bibliographystyle{h-physrev5}


\end{document}